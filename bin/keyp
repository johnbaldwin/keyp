#!/usr/bin/env ruby
# encoding: UTF-8

#
# NOTE: This is my first ruby gem and first executable ruby gem. I see a bunch of different
# implementations. A good number and a few well known use Thor, so seems like a good idea to
# figure out how to use Thor as well.
#
# I'm trying out some of the different impementations for Keyp, learning how they work, pros and cons
# Then I'll pick a single approach after exploring them

# TO run in the project dir:
# ruby -Ilib ./bin/keyp

# resolve bin path, ignoring symlinks
require 'pathname'
bin_file = Pathname.new(__FILE__).realpath

# http://davetron5000.github.io/gli/
require 'gli'

require 'pp'

require 'keyp'
include GLI::App

# keyp set key=value
# keyp get key
# keyp


# keyp create bag

program_desc 'A command line linterface for the Keyp key/value manager'

flag [:b,:bag], default_value: 'default'
switch [:d, :debug]

# TODO: fix this because this implies that we either already have a bag or it will create a new one
pre do |global_options, command, options, args|
  # initialize our store
  $debug = global_options[:debug]
  if $debug
    puts "pre-hook"
    puts "command:"
    pp command
    puts "options:"
    puts options
    puts "args: #{args}"
    puts "args.class=#{args.class}"
    puts "---- end prehook ---"
  end

  unless command.name ==  :setup

    # check if we are configured
    unless Keyp.configured?
      puts "Please run setup to use Keyp. Run with --help to view help menu"
      exit 1
    end

    $bag = Keyp.bag(global_options[:bag])
  else
    $bag = nil
  end
  true # hack to prevent
end

#
# Key,value commands
#arg_name 'keys', :multiple
command :get do |c|
  c.action do |global_options,options,args|
  puts "--- get args= #{args}" if $debug
    if args.length == 0
      puts "Usage: keyp get KEY"
      puts "Must specify a key."
    else
      val = $bag.data[args[0]]
      unless val.nil?
        puts val
      else
        puts ''
      end
    end
  end
end

# TODO: set is not optimal. Right now it only handles a single key/value pair and
# any global or command parameters after the key=value will be sucked into the value
# Se we'll need to implement values in quotes if the value contains whitespace

arg_name 'values', :multiple
command :set do |c|
  c.action do |global_options,options,args|
    # When/if implementing multiple key assignments
    # check args.length % 2
    # parse the args,

    # concatenate all the args
    # then parse on =
    buff = ''
    args.each do |arg|
      buff << arg << ' '
      buff
    end

    nvp = Keyp.parse_arg_string buff

    if nvp
      $bag[nvp[:key]] = nvp[:value]
    else
      # puts "Usage keyp set KEY1=VALUE1 [KEY2=VALUE2 ...]"
      puts "Usage: keyp set KEY=VALUE"
    end

    # $bag.data[]
  end
end

command :unset do |c|
  c.action do |global_options,options, args|
    if args.length == 0
      # puts 'Usage: keyp unset KEY1 [KEY2 ...]'
      puts 'Usage: keyp unset KEY1'
      puts 'Must specify a key to unset.'
    else
      printf "Unsetting #{args[0]}..."
      # if delete
      val = $bag.delete(args[0])
      if val
        puts "unset #{args[0]}: #{val}"
        printf "done.\n"
      else
        puts "key \"#{args[0]}\" not found"
      end

    end
  end
end

command :list do |c|
  c.action do
    puts "* bag:#{$bag.name}"

    unless $bag.empty?
      $bag.data.each do |key,value|
        #printf("$s : $s\n", key,value)
        puts "#{key}: #{value}"
      end
    else
      puts "You have an empty bag."
    end

  end
end


command :setup do |c|
  c.action do |global_options, options, args|
    puts "keyp setup..."
    Keyp::setup
    $bag = Keyp::create_store 'default'
  end
end

command :create do |c|
  c.action do |global_options, options, args|
    puts "keyp create"
    # TODO: add checking in case store already exists
    #Keyp::create

  end
end

post do |global_options, command, options, args|
  # if bag.data is dirty, then save
  if $debug
    puts "post-hook, state of bag.dirty = #{$bag.dirty}"
  end

  unless command.name == :setup
    $bag.save
  else
    true
  end



end
# bag management commands

# create a bag
# command :create

# delete a bag (with confirmation)

# show bags
# command :show




exit run(ARGV)
