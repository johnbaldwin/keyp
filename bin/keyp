#!/usr/bin/env ruby
# encoding: UTF-8

#
# NOTE: This is my first ruby gem and first executable ruby gem. I see a bunch of different
# implementations. A good number and a few well known use Thor, so seems like a good idea to
# figure out how to use Thor as well.
#
# I'm trying out some of the different impementations for Keyp, learning how they work, pros and cons
# Then I'll pick a single approach after exploring them

# TO run in the project dir:
# ruby -Ilib ./bin/keyp

# resolve bin path, ignoring symlinks
require 'pathname'
bin_file = Pathname.new(__FILE__).realpath

# http://davetron5000.github.io/gli/
require 'gli'


require 'keyp'
include GLI::App

# keyp set key=value
# keyp get key
# keyp


# keyp create bag

program_desc 'A command line linterface for the Keyp key/value manager'

flag [:b,:bag], default_value: 'default'
switch [:d, :debug]

# TODO: fix this because this implies that we either already have a bag or it will create a new one
pre do |global_options, command, options, args|
  # initialize our store
  $debug = global_options[:debug]
  if $debug
    puts "pre-hook"
    puts "command=#{command}"
    puts "options:"
    puts options
    puts "args: #{args}"
    puts "args.class=#{args.class}"
    puts "---- end prehook ---"
  end
  $bag = Keyp.bag(global_options[:bag])
end

#
# Key,value commands
command :get do |c|
  c.action do |global_options,options,args|
  puts "--- get args= #{args}" if $debug
    if args.length == 0
      puts "Usage: keyp get KEY"
      puts "Must specify a key."
    else
      val = $bag.data[args[0]]
      unless val.nil?
        puts val
      else
        puts ''
      end
    end
  end
end

# TODO: set is broken. need to tell GLI that terms after set are key value pairs with equal sign between each
# KV pair
# also need to implement tokenization
command :set do |c|
  c.action do |global_options,options,args|
    # When/if implementing multiple key assignments
    # check args.length % 2
    # parse the args,

    if args.length < 2
      # puts "Usage keyp set KEY1=VALUE1 [KEY2=VALUE2 ...]"
      puts "Usage: keyp set KEY=VALUE"
    else
      $bag.data[args[0]] = args[1]
    end
    # $bag.data[]
  end
end

command :unset do |c|
  c.action do |global_options,options, args|
    if args.length == 0
      # puts 'Usage: keyp unset KEY1 [KEY2 ...]'
      puts 'Usage: keyp unset KEY1'
      puts 'Must specify a key to unset.'
    else
      printf "Unsetting #{args[0]}..."
      $bag.data.delete(args[0])
      printf "done.\n"
    end
  end
end

command :list do |c|
  c.action do
    $bag.data.each do |key,value|
      #printf("$s : $s\n", key,value)
      puts "#{key}: #{value}"
    end
  end
end

post do |global_options, command, options, args|
  # if bag.data is dirty, then save

end
# bag management commands

# create a bag
# command :create

# delete a bag (with confirmation)

# show bags
# command :show




exit run(ARGV)
